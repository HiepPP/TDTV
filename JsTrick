///Set time to sleep
function sleep(milliseconds) {
  var start = new Date().getTime();
  for (var i = 0; i < 1e7; i++) {
    if ((new Date().getTime() - start) > milliseconds){
      break;
    }
  }
}

///Trigger change event when document.ready
$("select#ProvinceId").trigger('change',function () {}

///Remove validate
$(this).rules('remove', 'required');

// Call property from prototype
Gadget.prototype.get = function(what) {
return this[what];
};

///Apply vs call
The difference is that apply lets you invoke the function with arguments as an array; 
call requires the parameters be listed explicitly. A useful mnemonic is "A for array and C for comma."
Pseudo syntax:

+ theFunction.apply(valueForThis, arrayOfArgs)

+ theFunction.call(valueForThis, arg1, arg2, ...)

///normal map and Array.prototype.map.call
              var numbers = [1, 4, 9];
              var doubles = numbers.map(function(num) {
                return num * 2;
              });
==> work with array, can't work with string.
                  var str = '12345';
                  Array.prototype.map.call(str, function(x) {
                    return x;
                  }).reverse().join(''); 
==> work with string and array

//back button redirect to anotehr page
if (window.history && window.history.pushState) {
                window.history.pushState('', null, '');
                @{var url = new UrlHelper(Request.RequestContext).Action("Index", "Landing"); }
                $(window).on('popstate', function () {
                    window.location.href = '@url';
                });
            }
           
///Convert 1D array to multidimension array
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]

    var newArr = [];
    while (arr.length > 0 ) {
      newArr.push(arr.splice(0, 2));
}

///Count item with reduce
var names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice'];

var countedNames = names.reduce(function (allNames, name) { 
  if (name in allNames) {
    allNames[name]++;
  }
  else {
    allNames[name] = 1;
  }
  return allNames;
}, {});
